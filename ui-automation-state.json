{
  "status": "verified",
  "verification_summary": "Verified that the windows_uia JSON schema matches the unified UIElement interface. The Node.js UIProvider correctly parses the OS-specific JSON into the unified UIElement interface, ensuring all required properties (id, name, role, bounds, isClickable, isFocusable, children) are properly mapped and typed.",
  "windows_uia": {
    "status": "completed",
    "technology": "C# .NET Console Application (System.Windows.Automation)",
    "prototype_code": "using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text.Json;\nusing System.Windows.Automation;\n\nnamespace UIAWrapper\n{\n    class Program\n    {\n        [DllImport(\"user32.dll\")]\n        static extern IntPtr GetForegroundWindow();\n\n        static void Main(string[] args)\n        {\n            IntPtr handle = GetForegroundWindow();\n            if (handle == IntPtr.Zero) return;\n\n            AutomationElement root = AutomationElement.FromHandle(handle);\n            var node = BuildTree(root);\n\n            string json = JsonSerializer.Serialize(node, new JsonSerializerOptions { WriteIndented = true });\n            Console.WriteLine(json);\n        }\n\n        static UIANode BuildTree(AutomationElement element)\n        {\n            var node = new UIANode\n            {\n                id = element.Current.AutomationId,\n                name = element.Current.Name,\n                role = element.Current.ControlType.ProgrammaticName.Replace(\"ControlType.\", \"\"),\n                bounds = new Bounds\n                {\n                    x = element.Current.BoundingRectangle.X,\n                    y = element.Current.BoundingRectangle.Y,\n                    width = element.Current.BoundingRectangle.Width,\n                    height = element.Current.BoundingRectangle.Height\n                },\n                isClickable = (bool)element.GetCurrentPropertyValue(AutomationElement.IsInvokePatternAvailableProperty) || element.Current.IsKeyboardFocusable,\n                isFocusable = element.Current.IsKeyboardFocusable,\n                children = new List<UIANode>()\n            };\n\n            var walker = TreeWalker.ControlViewWalker;\n            var child = walker.GetFirstChild(element);\n            while (child != null)\n            {\n                try\n                {\n                    if (!child.Current.IsOffscreen)\n                    {\n                        node.children.Add(BuildTree(child));\n                    }\n                }\n                catch (ElementNotAvailableException) { }\n                \n                child = walker.GetNextSibling(child);\n            }\n\n            return node;\n        }\n    }\n\n    class UIANode\n    {\n        public string id { get; set; }\n        public string name { get; set; }\n        public string role { get; set; }\n        public Bounds bounds { get; set; }\n        public bool isClickable { get; set; }\n        public bool isFocusable { get; set; }\n        public List<UIANode> children { get; set; }\n    }\n\n    class Bounds\n    {\n        public double x { get; set; }\n        public double y { get; set; }\n        public double width { get; set; }\n        public double height { get; set; }\n    }\n}",
    "json_schema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": { \"type\": \"string\" },\n    \"name\": { \"type\": \"string\" },\n    \"role\": { \"type\": \"string\" },\n    \"bounds\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"x\": { \"type\": \"number\" },\n        \"y\": { \"type\": \"number\" },\n        \"width\": { \"type\": \"number\" },\n        \"height\": { \"type\": \"number\" }\n      },\n      \"required\": [\"x\", \"y\", \"width\", \"height\"]\n    },\n    \"isClickable\": { \"type\": \"boolean\" },\n    \"isFocusable\": { \"type\": \"boolean\" },\n    \"children\": {\n      \"type\": \"array\",\n      \"items\": { \"$ref\": \"#\" }\n    }\n  },\n  \"required\": [\"id\", \"name\", \"role\", \"bounds\", \"isClickable\", \"isFocusable\", \"children\"]\n}"
  },
  "macos_ax": {
    "status": "pending",
    "technology": null,
    "prototype_code": null,
    "json_schema": null
  },
  "node_bridge": {
    "status": "completed",
    "interface_code": "const { spawn } = require('child_process');\r\nconst path = require('path');\r\n\r\n/**\r\n * @typedef {Object} Bounds\r\n * @property {number} x\r\n * @property {number} y\r\n * @property {number} width\r\n * @property {number} height\r\n */\r\n\r\n/**\r\n * @typedef {Object} UIElement\r\n * @property {string} id\r\n * @property {string} name\r\n * @property {string} role\r\n * @property {Bounds} bounds\r\n * @property {boolean} isClickable\r\n * @property {boolean} isFocusable\r\n * @property {UIElement[]} children\r\n */\r\n\r\nclass UIProvider {\r\n  constructor() {\r\n    // Assuming the binary is compiled to bin/windows-uia.exe relative to project root\r\n    this.binaryPath = path.join(__dirname, '..', '..', '..', '..', 'bin', 'windows-uia.exe');\r\n  }\r\n\r\n  /**\r\n   * Fetches the UI tree from the native binary.\r\n   * @returns {Promise<UIElement>}\r\n   */\r\n  async getUITree() {\r\n    return new Promise((resolve, reject) => {\r\n      const child = spawn(this.binaryPath);\r\n      let output = '';\r\n      let errorOutput = '';\r\n\r\n      child.stdout.on('data', (data) => {\r\n        output += data.toString();\r\n      });\r\n\r\n      child.stderr.on('data', (data) => {\r\n        errorOutput += data.toString();\r\n      });\r\n\r\n      child.on('close', (code) => {\r\n        if (code !== 0) {\r\n          return reject(new Error(`Process exited with code ${code}: ${errorOutput}`));\r\n        }\r\n\r\n        try {\r\n          const parsed = JSON.parse(output);\r\n          const uiTree = this.parseNode(parsed);\r\n          resolve(uiTree);\r\n        } catch (err) {\r\n          reject(new Error(`Failed to parse JSON output: ${err.message}`));\r\n        }\r\n      });\r\n      \r\n      child.on('error', (err) => {\r\n        reject(new Error(`Failed to start subprocess: ${err.message}`));\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Parses the OS-specific JSON node into a unified UIElement.\r\n   * @param {Object} node\r\n   * @returns {UIElement}\r\n   */\r\n  parseNode(node) {\r\n    return {\r\n      id: node.id || '',\r\n      name: node.name || '',\r\n      role: node.role || '',\r\n      bounds: {\r\n        x: node.bounds?.x || 0,\r\n        y: node.bounds?.y || 0,\r\n        width: node.bounds?.width || 0,\r\n        height: node.bounds?.height || 0\r\n      },\r\n      isClickable: !!node.isClickable,\r\n      isFocusable: !!node.isFocusable,\r\n      children: (node.children || []).map(child => this.parseNode(child))\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = { UIProvider };\r\n",
    "ipc_code": "const { ipcMain } = require('electron');\nconst { UIProvider } = require('./ui-provider');\n\nfunction setupIPC() {\n  const uiProvider = new UIProvider();\n  \n  ipcMain.handle('get-ui-tree', async () => {\n    try {\n      const tree = await uiProvider.getUITree();\n      return { success: true, data: tree };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  });\n}\n\nmodule.exports = { setupIPC };"
  },
  "ai_context_strategy": {
    "status": "completed",
    "summary": "AI messages now include a grounded Semantic DOM section from UIProvider snapshots with pruning, freshness gating, and character limits.",
    "rules": {
      "maxDepth": 4,
      "maxNodes": 120,
      "maxChars": 3500,
      "maxAgeMs": 5000
    }
  },
  "electron_overlay": {
    "status": "completed",
    "rendering_code": "Main process now prefers cached UIProvider regions for overlay update-inspect-regions and falls back to UIWatcher regions when provider data is stale/unavailable."
  }
}